
/* ================================
   LOGIN
================================ */

export const login = async (req: Request, res: Response) => {
  const { email, password } = req.body;
  const emailNormalized = email ? String(email).toLowerCase().trim() : email;

  if (!email || !password) {
    return res.status(400).json({ message: "username and password are required" });
  }

  const [user] = await db.select().from(users).where(eq(users.email, emailNormalized));

  if (!user) {
    return res.status(401).json({ message: "Invalid credentials" });
  }

  const isMatch = await bcrypt.compare(password, user.passwordHash);
  if (!isMatch) {
    return res.status(401).json({ message: "Invalid credentials" });
  }

  // revoke all refresh tokens
  await db
    .update(refreshTokens)
    .set({ revoked: true })
    .where(eq(refreshTokens.userId, user.id));

  const accessToken = generateAccessToken({
    userId: user.id,
    role: user.role as Role,
  });

  const refreshToken = generateRefreshToken({
    userId: user.id,
  });

  await db.insert(refreshTokens).values({
    userId: user.id,
    tokenHash: hashToken(refreshToken),
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
  });

  res.cookie("accessToken", accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: 15 * 60 * 1000,
  });

  res.cookie("refreshToken", refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  res.json({
    message: "Login successful",
    role: user.role,
    accessToken,
  });
};

/* ================================
   REFRESH TOKEN
================================ */

export const refreshAccessToken = async (req: Request, res: Response) => {
  const refreshToken = req.cookies.refreshToken;

  if (!refreshToken) {
    return res.status(401).json({ message: "Refresh token missing" });
  }

  try {
    const decoded = jwt.verify(
      refreshToken,
      process.env.JWT_REFRESH_SECRET!
    ) as { userId: number };

    const [storedToken] = await db
      .select()
      .from(refreshTokens)
      .where(eq(refreshTokens.tokenHash, hashToken(refreshToken)));

    if (!storedToken || storedToken.revoked) {
      return res.status(401).json({ message: "Session expired" });
    }

    // load the user's current role from the database instead of relying on req.user
    const [dbUser] = await db.select().from(users).where(eq(users.id, decoded.userId));

    if (!dbUser) {
      return res.status(401).json({ message: "User not found" });
    }

    const newAccessToken = generateAccessToken({
      userId: decoded.userId,
      role: dbUser.role as Role,
    });

    res.cookie("accessToken", newAccessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
      maxAge: 15 * 60 * 1000,
    });

    res.json({ message: "Token refreshed" });
  } catch {
    res.status(401).json({ message: "Invalid refresh token" });
  }
};

/* ================================
   LOGOUT
================================ */

export const logout = (_req: Request, res: Response) => {
  res.clearCookie("accessToken");
  res.clearCookie("refreshToken");
  res.json({ message: "Logged out successfully" });
};
