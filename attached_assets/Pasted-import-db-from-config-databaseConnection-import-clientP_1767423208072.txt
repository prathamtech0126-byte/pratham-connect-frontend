import { db } from "../config/databaseConnection";
import {
  clientProductPayments,
  productTypeEnum,
  entityTypeEnum,
} from "../schemas/clientProductPayments.schema";
import { clientInformation } from "../schemas/clientInformation.schema";
import { simCard } from "../schemas/simCard.schema";
import { airTicket } from "../schemas/airTicket.schema";
import { ielts } from "../schemas/ielts.schema";
import { loan } from "../schemas/loan.schema";
import { forexCard } from "../schemas/forexCard.schema";
import { forexFees } from "../schemas/forexFees.schema";
import { tutionFees } from "../schemas/tutionFees.schema";
import { insurance } from "../schemas/insurance.schema";
import { beaconAccount } from "../schemas/beaconAccount.schema";
import { creditCard } from "../schemas/creditCard.schema";
import { newSell } from "../schemas/newSell.schema";
import { visaExtension } from "../schemas/visaExtension.schema";
import { eq, inArray } from "drizzle-orm";

// Product type enum values
export type ProductType =
  | "ALL_FINANCE_EMPLOYEMENT"
  | "INDIAN_SIDE_EMPLOYEMENT"
  | "NOC_LEVEL_JOB_ARRANGEMENT"
  | "LAWYER_REFUSAL_CHARGE"
  | "ONSHORE_PART_TIME_EMPLOYEMENT"
  | "TRV_WORK_PERMIT_EXT_STUDY_PERMIT_EXTENSION"
  | "MARRIAGE_PHOTO_FOR_COURT_MARRIAGE"
  | "MARRIAGE_PHOTO_CERTIFICATE"
  | "RECENTE_MARRIAGE_RELATIONSHIP_AFFIDAVIT"
  | "JUDICAL_REVIEW_CHARGE"
  | "SIM_CARD_ACTIVATION"
  | "INSURANCE"
  | "BEACON_ACCOUNT"
  | "AIR_TICKET"
  | "OTHER_NEW_SELL"
  | "SPONSOR_CHARGES"
  | "FINANCE_EMPLOYEMENT"
  | "IELTS_ENROLLMENT"
  | "LOAN_DETAILS"
  | "FOREX_CARD"
  | "FOREX_FEES"
  | "TUTION_FEES"
  | "CREDIT_CARD"
  | "VISA_EXTENSION";

// Entity type enum values
export type EntityType =
  | "visaextension_id"
  | "simCard_id"
  | "airTicket_id"
  | "newSell_id"
  | "ielts_id"
  | "loan_id"
  | "forexCard_id"
  | "forexFees_id"
  | "tutionFees_id"
  | "insurance_id"
  | "beaconAccount_id"
  | "creditCard_id"
  | "master_only";

// Map product name to entity type
const productToEntityTypeMap: Record<ProductType, EntityType> = {
  SIM_CARD_ACTIVATION: "simCard_id",
  AIR_TICKET: "airTicket_id",
  IELTS_ENROLLMENT: "ielts_id",
  LOAN_DETAILS: "loan_id",
  FOREX_CARD: "forexCard_id",
  FOREX_FEES: "forexFees_id",
  TUTION_FEES: "tutionFees_id",
  INSURANCE: "insurance_id",
  BEACON_ACCOUNT: "beaconAccount_id",
  CREDIT_CARD: "creditCard_id",
  OTHER_NEW_SELL: "newSell_id",
  VISA_EXTENSION: "visaextension_id",
  // Products without specific tables use newSell
  // âœ… MASTER-ONLY PRODUCTS
  ALL_FINANCE_EMPLOYEMENT: "master_only",
  INDIAN_SIDE_EMPLOYEMENT: "master_only",
  NOC_LEVEL_JOB_ARRANGEMENT: "master_only",
  LAWYER_REFUSAL_CHARGE: "master_only",
  ONSHORE_PART_TIME_EMPLOYEMENT: "master_only",
  TRV_WORK_PERMIT_EXT_STUDY_PERMIT_EXTENSION: "master_only",
  MARRIAGE_PHOTO_FOR_COURT_MARRIAGE: "master_only",
  MARRIAGE_PHOTO_CERTIFICATE: "master_only",
  RECENTE_MARRIAGE_RELATIONSHIP_AFFIDAVIT: "master_only",
  JUDICAL_REVIEW_CHARGE: "master_only",
  SPONSOR_CHARGES: "master_only",
  FINANCE_EMPLOYEMENT: "master_only",
};

// Map entity type to table for validation
const entityTypeToTable: Record<EntityType, any> = {
  simCard_id: simCard,
  airTicket_id: airTicket,
  ielts_id: ielts,
  loan_id: loan,
  forexCard_id: forexCard,
  forexFees_id: forexFees,
  tutionFees_id: tutionFees,
  insurance_id: insurance,
  beaconAccount_id: beaconAccount,
  creditCard_id: creditCard,
  newSell_id: newSell,
  visaextension_id: visaExtension,
  master_only:null
};

// Entity data interfaces
interface SimCardData {
  activatedStatus?: boolean;
  simcardPlan?: string;
  simCardGivingDate?: string;
  simActivationDate?: string;
  remarks?: string;
}

interface AirTicketData {
  isTicketBooked?: boolean;
  amount?: number | string;
  airTicket?: string;
  ticketDate?: string;
  remarks?: string;
}

interface IeltsData {
  enrolledStatus?: boolean;
  amount: number | string;
  enrollmentDate?: string;
  remarks?: string;
}

interface LoanData {
  amount: number | string;
  disbursmentDate?: string;
  remarks?: string;
}

interface ForexCardData {
  forexCardStatus?: string;
  cardDate?: string;
  remarks?: string;
}

interface ForexFeesData {
  side: "PI" | "TP";
  amount: number | string;
  feeDate?: string;
  remarks?: string;
}

interface TutionFeesData {
  tutionFeesStatus: "paid" | "pending";
  feeDate?: string;
  remarks?: string;
}

interface InsuranceData {
  amount: number | string;
  insuranceDate?: string;
  remarks?: string;
}

interface BeaconAccountData {
  amount: number | string;
  accountDate?: string;
  remarks?: string;
}

interface CreditCardData {
  amount: number | string;
  cardDate?: string;
  remarks?: string;
}

interface VisaExtensionData {
  type: string;
  amount: number | string;
  extensionDate?: string;
  invoiceNo?: string;
  remarks?: string;
}

interface NewSellData {
  serviceName: string;
  serviceInformation?: string;
  amount: number | string;
  sellDate?: string;
  remarks?: string;
}

interface SaveClientProductPaymentInput {
  productPaymentId?: number;
  clientId: number;
  productName: ProductType;
  invoiceNo?: string;
  amount: number | string;
  paymentDate?: string;
  remarks?: string;
  entityId?: number;
  // Entity data based on product type
  entityData?:
    | SimCardData
    | AirTicketData
    | IeltsData
    | LoanData
    | ForexCardData
    | ForexFeesData
    | TutionFeesData
    | InsuranceData
    | BeaconAccountData
    | CreditCardData
    | VisaExtensionData
    | NewSellData;
}

// Helper function to create entity record
const createEntityRecord = async (
  entityType: EntityType,
  entityData: any,
  productAmount: number | string = 0,
  remarks?: string
): Promise<number> => {
  const amountValue =
    typeof productAmount === "string"
      ? parseFloat(productAmount)
      : productAmount;

  switch (entityType) {
    case "simCard_id": {
      const data = entityData as SimCardData;
      const [record] = await db
        .insert(simCard)
        .values({
          activatedStatus: data.activatedStatus ?? false,
          simcardPlan: data.simcardPlan ?? null,
          simCardGivingDate: data.simCardGivingDate ?? null,
          simActivationDate: data.simActivationDate ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    case "airTicket_id": {
      const data = entityData as AirTicketData;
      const [record] = await db
        .insert(airTicket)
        .values({
          isTicketBooked: data.isTicketBooked ?? false,
          amount: data.amount ? data.amount.toString() : amountValue.toString(),
          airTicket: data.airTicket ?? null,
          ticketDate: data.ticketDate ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    case "ielts_id": {
      const data = entityData as IeltsData;
      const [record] = await db
        .insert(ielts)
        .values({
          enrolledStatus: data.enrolledStatus ?? false,
          amount: data.amount.toString(),
          enrollmentDate: data.enrollmentDate ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    case "loan_id": {
      const data = entityData as LoanData;
      const [record] = await db
        .insert(loan)
        .values({
          amount: data.amount.toString(),
          disbursmentDate: data.disbursmentDate ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    case "forexCard_id": {
      const data = entityData as ForexCardData;
      const [record] = await db
        .insert(forexCard)
        .values({
          forexCardStatus: data.forexCardStatus ?? null,
          cardDate: data.cardDate ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    case "forexFees_id": {
      const data = entityData as ForexFeesData;
      if (!data.side || !["PI", "TP"].includes(data.side)) {
        throw new Error("side is required and must be 'PI' or 'TP'");
      }
      const [record] = await db
        .insert(forexFees)
        .values({
          side: data.side as any,
          amount: data.amount.toString(),
          feeDate: data.feeDate ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    case "tutionFees_id": {
      const data = entityData as TutionFeesData;
      if (
        !data.tutionFeesStatus ||
        !["paid", "pending"].includes(data.tutionFeesStatus)
      ) {
        throw new Error(
          "tutionFeesStatus is required and must be 'paid' or 'pending'"
        );
      }
      const [record] = await db
        .insert(tutionFees)
        .values({
          tutionFeesStatus: data.tutionFeesStatus as any,
          feeDate: data.feeDate ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    case "insurance_id": {
      const data = entityData as InsuranceData;
      const [record] = await db
        .insert(insurance)
        .values({
          amount: data.amount.toString(),
          insuranceDate: data.insuranceDate ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    case "beaconAccount_id": {
      const data = entityData as BeaconAccountData;
      const [record] = await db
        .insert(beaconAccount)
        .values({
          amount: data.amount.toString(),
          accountDate: data.accountDate ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    case "creditCard_id": {
      const data = entityData as CreditCardData;
      const [record] = await db
        .insert(creditCard)
        .values({
          amount: data.amount.toString(),
          cardDate: data.cardDate ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    case "visaextension_id": {
      const data = entityData as VisaExtensionData;
      if (!data.type) {
        throw new Error("type is required for visa extension");
      }
      const [record] = await db
        .insert(visaExtension)
        .values({
          type: data.type,
          amount: data.amount.toString(),
          extensionDate: data.extensionDate ?? null,
          invoiceNo: data.invoiceNo ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    case "newSell_id": {
      const data = entityData as NewSellData;
      if (!data.serviceName) {
        throw new Error("serviceName is required for new sell");
      }
      const [record] = await db
        .insert(newSell)
        .values({
          serviceName: data.serviceName,
          serviceInformation: data.serviceInformation ?? null,
          amount: data.amount.toString(),
          sellDate: data.sellDate ?? null,
          remarks: data.remarks ?? null,
        })
        .returning();
      return record.id;
    }

    default:
      throw new Error(`Unsupported entity type: ${entityType}`);
  }
};


export const saveClientProductPayment = async (
  data: SaveClientProductPaymentInput
) => {
  const {
    productPaymentId,
    clientId,
    productName,
    amount,
    paymentDate,
    remarks,
    invoiceNo,
    entityData,
  } = data;

  if (!clientId || !productName) {
    throw new Error("clientId and productName are required");
  }

  const entityType = productToEntityTypeMap[productName];
  if (!entityType) throw new Error("Invalid productName");

  // ---------------------------
  // AMOUNT VALIDATION (STRICT)
  // ---------------------------
  let amountValue: number | null = null;

  if (entityType === "master_only") {
    if (amount === undefined || amount === null) {
      throw new Error("amount is required for master_only products");
    }

    amountValue = typeof amount === "string" ? parseFloat(amount) : amount;

    if (!isFinite(amountValue) || amountValue <= 0) {
      throw new Error("Invalid amount");
    }
  }

  // ---------------------------
  // UPDATE
  // ---------------------------
  if (productPaymentId) {
    const [existing] = await db
      .select()
      .from(clientProductPayments)
      .where(eq(clientProductPayments.productPaymentId, productPaymentId));

    if (!existing) throw new Error("Record not found");

    // update entity table only if exists
    if (entityData && entityType !== "master_only") {
      const table = entityTypeToTable[entityType];
      await db
        .update(table)
        .set(entityData)
        .where(eq(table.id, existing.entityId));
    }

    const [updated] = await db
      .update(clientProductPayments)
      .set({
        amount:
          entityType === "master_only"
            ? amountValue!.toString()
            : existing.amount,
        paymentDate: paymentDate ?? existing.paymentDate,
        invoiceNo: invoiceNo ?? existing.invoiceNo,
        remarks: remarks ?? existing.remarks,
      })
      .where(eq(clientProductPayments.productPaymentId, productPaymentId))
      .returning();

    return { action: "UPDATED", record: updated };
  }

  // ---------------------------
  // CREATE
  // ---------------------------
  let entityId: number | null = null;

  if (entityType !== "master_only") {
    if (!entityData) {
      throw new Error("entityData required");
    }

    entityId = await createEntityRecord(entityType, entityData);
  }

  const [record] = await db
    .insert(clientProductPayments)
    .values({
      clientId,
      productName: productName as any,
      entityType: entityType as any,
      entityId,
      amount:
        entityType === "master_only"
          ? amountValue!.toString()
          : null,
      paymentDate: paymentDate ?? null,
      invoiceNo: invoiceNo ?? null,
      remarks: remarks ?? null,
    })
    .returning();

  return { action: "CREATED", record };
};


export const getProductPaymentsByClientId = async (clientId: number) => {
  const payments = await db
    .select()
    .from(clientProductPayments)
    .where(eq(clientProductPayments.clientId, clientId));

  if (payments.length === 0) return [];

  // ---- BEACON ----
  const beaconIds = payments
    .filter(p => p.entityType === "beaconAccount_id")
    .map(p => p.entityId!)
    .filter(Boolean);

  const beaconAccounts = beaconIds.length
    ? await db
        .select()
        .from(beaconAccount)
        .where(inArray(beaconAccount.id, beaconIds))
    : [];

  const beaconMap = new Map(
    beaconAccounts.map(b => [b.id, b])
  );

  // ---- MERGE ----
  return payments.map(p => {
    if (p.entityType === "beaconAccount_id") {
      return {
        ...p,
        entity: beaconMap.get(p.entityId!) || null,
      };
    }

    return {
      ...p,
      entity: null,
    };
  });
};
