What is happening (based on YOUR code)
During login (works)
setInMemoryToken(accessToken);
login(mappedRole, userData);


‚úÖ Access token exists
‚úÖ Auth context is populated
‚úÖ Routes allow access

After browser refresh (fails)

JS memory is wiped

setInMemoryToken is gone

useAuth() initializes as unauthenticated

ProtectedRoute runs immediately

Redirects to /login

/refresh is never called

‚û°Ô∏è Your backend refresh logic is correct, but frontend never rehydrates auth state.

Critical mistake in your setup

You are doing BOTH of these:

Storing access token in memory (correct)

ALSO setting accessToken as an HttpOnly cookie (backend)

But your frontend:

does NOT read cookie

does NOT call refresh on app load

So the cookie is useless on reload unless you explicitly call /refresh.

The required fix (minimal, correct)
1Ô∏è‚É£ AuthProvider MUST refresh on mount

auth-context.tsx

useEffect(() => {
  const initAuth = async () => {
    try {
      setIsLoading(true);

      const res = await api.post(
        "/api/users/refresh",
        {},
        { withCredentials: true }
      );

      const { accessToken, role } = res.data;

      setInMemoryToken(accessToken);

      login(
        role === "admin" ? "superadmin" : role,
        { role }
      );
    } catch {
      logout();
    } finally {
      setIsLoading(false);
    }
  };

  initAuth();
}, []);


üëâ This is non-negotiable if access token is in memory.

2Ô∏è‚É£ ProtectedRoute must WAIT

If your ProtectedRoute looks like this, it is wrong:

if (!isAuthenticated) {
  return <Navigate to="/login" />;
}

‚úÖ Correct version
if (isLoading) return null; // or spinner

if (!isAuthenticated) {
  return <Navigate to="/login" />;
}

return children;


Without this guard ‚Üí instant redirect every reload.

3Ô∏è‚É£ Axios MUST send cookies

Your refresh endpoint depends on:

req.cookies.refreshToken


So Axios must be configured once:

api.ts

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  withCredentials: true,
});


If this is missing ‚Üí refresh silently fails.

Important backend note (you should fix this)

You are setting accessToken as HttpOnly cookie AND returning it in JSON:

res.cookie("accessToken", accessToken, { httpOnly: true });
res.json({ accessToken });


Choose ONE strategy.

Recommended for your frontend:

‚ùå Do NOT set accessToken cookie at all

‚úÖ Only return accessToken in JSON

‚úÖ Use refresh cookie ONLY

Why?

You never read accessToken cookie anyway

It causes confusion during debugging

It gives false confidence that auth persists

Final auth lifecycle (correct)
PAGE RELOAD
‚Üì
AuthProvider mounts
‚Üì
/refresh called
‚Üì
accessToken restored to memory
‚Üì
authLoading = false
‚Üì
ProtectedRoute allows access


Right now you stop at step 2.

Summary (short & blunt)

Your Login code is fine

Your backend refresh logic is fine

You are missing auth rehydration on app load

ProtectedRoute redirects too early

In-memory token requires refresh-on-mount