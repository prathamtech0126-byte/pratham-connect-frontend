import { Request, Response } from "express";
import {
  createUser,
  getAllUsers,
  updateUserByAdmin,
  deleteUserByAdmin,
  getAllManagers,
} from "../models/user.model";
import bcrypt from "bcrypt";
import { db } from "../config/databaseConnection";
import { users } from "../schemas/users.schema";
import { refreshTokens } from "../schemas/refreshToken.schema";
import {
  generateAccessToken,
  generateRefreshToken,
  hashToken,
} from "../utils/token";
import { eq } from "drizzle-orm";
import jwt from "jsonwebtoken";
import { Role } from "../types/role";
import { AuthenticatedRequest } from "./../@types/express/auth";
/* ================================
   REGISTER
================================ */

export const registerUser = async (req: Request, res: Response) => {
  try {
    const authReq = req as AuthenticatedRequest;

    // normalize input: accept snake_case or variants from clients
    const body = req.body || {};
    const payload = {
      fullName: body.fullName ?? body.full_name,
      email: body.email ? body.email.toLowerCase().trim() : undefined,
      password: body.password,
      role: body.role,
      empId: body.empId ?? body.emp_id,
      managerId: body.managerId ?? body.manager_id,
      officePhone:
        body.officePhone ??
        body.office_phone ??
        body.company_phone_no ??
        body.office_phone_no,
      personalPhone:
        body.personalPhone ?? body.personal_phone ?? body.personal_phone_no,
      designation: body.designation,
    };

    const user = await createUser(payload as any, authReq.user.role);
    res.status(201).json(user);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
};

/* ================================
   LOGIN
================================ */

export const login = async (req: Request, res: Response) => {
  const { email, password } = req.body;
  const emailNormalized = email ? String(email).toLowerCase().trim() : email;

  if (!email || !password) {
    return res
      .status(400)
      .json({ message: "username and password are required" });
  }

  const [user] = await db
    .select()
    .from(users)
    .where(eq(users.email, emailNormalized));

  if (!user) {
    return res.status(401).json({ message: "Invalid credentials" });
  }

  const isMatch = await bcrypt.compare(password, user.passwordHash);
  if (!isMatch) {
    return res.status(401).json({ message: "Invalid credentials" });
  }

  // revoke all refresh tokens
  await db
    .update(refreshTokens)
    .set({ revoked: true })
    .where(eq(refreshTokens.userId, user.id));

  const accessToken = generateAccessToken({
    userId: user.id,
    role: user.role as Role,
  });

  const refreshToken = generateRefreshToken({
    userId: user.id,
  });

  await db.insert(refreshTokens).values({
    userId: user.id,
    tokenHash: hashToken(refreshToken),
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
  });

  res.cookie("accessToken", accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: 15 * 60 * 1000,
  });

  res.cookie("refreshToken", refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  res.json({
    message: "Login successful",
    role: user.role,
    accessToken,
  });
};

/* ================================
   REFRESH TOKEN
================================ */

export const refreshAccessToken = async (req: Request, res: Response) => {
  const refreshToken = req.cookies.refreshToken;

  if (!refreshToken) {
    return res.status(401).json({ message: "Refresh token missing" });
  }

  try {
    const decoded = jwt.verify(
      refreshToken,
      process.env.JWT_REFRESH_SECRET!
    ) as { userId: number };

    const [storedToken] = await db
      .select()
      .from(refreshTokens)
      .where(eq(refreshTokens.tokenHash, hashToken(refreshToken)));

    if (!storedToken || storedToken.revoked) {
      return res.status(401).json({ message: "Session expired" });
    }

    // load the user's current role from the database instead of relying on req.user
    const [dbUser] = await db
      .select()
      .from(users)
      .where(eq(users.id, decoded.userId));

    if (!dbUser) {
      return res.status(401).json({ message: "User not found" });
    }

    const newAccessToken = generateAccessToken({
      userId: decoded.userId,
      role: dbUser.role as Role,
    });

    res.cookie("accessToken", newAccessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
      maxAge: 15 * 60 * 1000,
    });

    res.json({
      message: "Token refreshed",
      accessToken: newAccessToken,
    });
  } catch {
    res.status(401).json({ message: "Invalid refresh token" });
  }
};

/* ================================
   LOGOUT
================================ */

export const logout = (_req: Request, res: Response) => {
  res.clearCookie("accessToken");
  res.clearCookie("refreshToken");
  res.json({ message: "Logged out successfully" });
};

/* ================================
   ADMIN CONTROLLERS
================================ */

export const getAllUsersController = async (_req: Request, res: Response) => {
  const users = await getAllUsers();
  res.json({ success: true, count: users.length, data: users });
};

export const updateUserController = async (req: Request, res: Response) => {
  const userId = Number(req.params.userId);

  const body = req.body || {};
  const payload = {
    fullName: body.fullName ?? body.full_name,
    email: body.email ? body.email.toLowerCase().trim() : undefined,
    password: body.password,
    role: body.role,
    empId: body.empId ?? body.emp_id,
    managerId: body.managerId ?? body.manager_id,
    officePhone:
      body.officePhone ??
      body.office_phone ??
      body.company_phone_no ??
      body.office_phone_no,
    personalPhone:
      body.personalPhone ?? body.personal_phone ?? body.personal_phone_no,
    designation: body.designation,
  };

  try {
    const updatedUser = await updateUserByAdmin(userId, payload as any);
    res.json({ success: true, data: updatedUser });
  } catch (error: any) {
    // Validation and uniqueness errors are returned as 400
    res
      .status(400)
      .json({ success: false, message: error?.message ?? String(error) });
  }
};

export const deleteUserController = async (req: Request, res: Response) => {
  const targetUserId = Number(req.params.userId);
  const adminUserId = (req as AuthenticatedRequest).user.id;

  const result = await deleteUserByAdmin(targetUserId, adminUserId);
  res.json({ success: true, message: result.message });
};

export const getManagersDropdown = async (_req: Request, res: Response) => {
  const managers = await getAllManagers();
  res.json({ success: true, count: managers.length, data: managers });
};
